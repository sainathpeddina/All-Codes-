üîë Key Features of the Map Interface
Each key maps to one value.
Duplicate keys are not allowed.
A map can contain null values and sometimes null keys, depending on the implementation.
It is not a subtype of Collection.

üß© Common Methods of the Map Interface
| Method                        | Description                                            |
| ----------------------------- | ------------------------------------------------------ |
| `put(K key, V value)`         | Associates the specified value with the specified key. |
| `get(Object key)`             | Returns the value associated with the key.             |
| `remove(Object key)`          | Removes the key-value pair for the key.                |
| `containsKey(Object key)`     | Returns true if the key exists.                        |
| `containsValue(Object value)` | Returns true if the value exists.                      |
| `keySet()`                    | Returns a set view of the keys.                        |
| `values()`                    | Returns a collection view of the values.               |
| `entrySet()`                  | Returns a set view of key-value mappings.              |


        HashMap<Integer, String> map = new HashMap<>();
        LinkedHashMap<Integer, String> map = new LinkedHashMap<>();
        TreeMap<Integer, String> map = new TreeMap<>();
        Hashtable<Integer, String> map = new Hashtable<>();
    
üìò Summary Table
| Implementation  | Order     | Null Keys | Null Values | Thread-safe |
| --------------- | --------- | --------- | ----------- | ----------- |
| `HashMap`       | No        | 1 allowed | Yes         | No          |
| `LinkedHashMap` | Insertion | 1 allowed | Yes         | No          |
| `TreeMap`       | Sorted    | No        | Yes         | No          |
| `Hashtable`     | No        | No        | No          | Yes         |

TreeMap - Maintains natural order (or custom order with a comparator).
Thread-safe = Yes >>>> Synchronized
Thread-safe = No >>>>> Not Synchronized



‚úÖ Commonly Used Methods of Map<K, V>
Let's consider a Map<Integer, String> where keys are Integer and values are String.
import java.util.*;
public class MapMethodsExample {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();

        // put()
        map.put(1, "Apple");
        map.put(2, "Banana");
        map.put(3, "Cherry");

        // get()
        System.out.println("Value for key 2: " + map.get(2));

        // containsKey() and containsValue()
        System.out.println("Contains key 3? " + map.containsKey(3));
        System.out.println("Contains value 'Banana'? " + map.containsValue("Banana"));

        // keySet()
        Set<Integer> keys = map.keySet(); 

        // values()
        Collection<String> values = map.values();  // [Avocado]
        System.out.println("All values: " + values);

        // entrySet()
        System.out.println("All entries:");
        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
 System.out.println("All keys: " + keys);
        }

        // remove()
        map.remove(2);
        System.out.println("After removing key 2: " + map);

        // putAll()
        Map<Integer, String> newMap = new HashMap<>();
        newMap.put(4, "Date");
        map.putAll(newMap);
        System.out.println("After putAll: " + map);

        // size()
        System.out.println("Map size: " + map.size());

        // isEmpty()
        System.out.println("Is map empty? " + map.isEmpty());

        // clear()
        map.clear();
        System.out.println("Map after clear: " + map);
    }
}

üîç Advanced Map Methods (Java 8+) with Examples

1. V getOrDefault(Object key, V defaultValue)
Returns the value for the key, or returns the default if the key is not found.
map.put(1, "Apple");
System.out.println(map.getOrDefault(1, "Unknown")); // Output: Apple
System.out.println(map.getOrDefault(2, "Unknown")); // Output: Unknown

2. void forEach(BiConsumer<? super K, ? super V> action)
Performs an action for each entry in the map.
map.forEach((key, value) -> {
    System.out.println("Key: " + key + ", Value: " + value);
});

3. V putIfAbsent(K key, V value)
Puts the value only if the key is not already present.
map.putIfAbsent(2, "Banana"); // Will add
map.putIfAbsent(1, "Avocado"); // Won't add, key 1 already exists
System.out.println(map); // {1=Apple, 2=Banana}

4. V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)
Recomputes the value for the key using a function. If the key is absent, value is computed with null.
map.compute(1, (key, val) -> val.toUpperCase()); // Apple -> APPLE
map.compute(3, (key, val) -> "Cherry");          // Adds key 3 with value "Cherry"
System.out.println(map); // {1=APPLE, 2=Banana, 3=Cherry}

5. V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)
Only computes and inserts the value if the key is not already present.
map.computeIfAbsent(4, key -> "Date");
map.computeIfAbsent(2, key -> "Dummy"); // Won't change, key 2 already exists
System.out.println(map); // {1=APPLE, 2=Banana, 3=Cherry, 4=Date}

6. V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)
Only recomputes if the key is already present.
map.computeIfPresent(3, (key, val) -> val + " Pie");
map.computeIfPresent(5, (key, val) -> "Fig"); // Won't add because key 5 doesn't exist
System.out.println(map); // {1=APPLE, 2=Banana, 3=Cherry Pie, 4=Date}

7. V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)
If key doesn't exist, insert value. If it exists, merge using remapping function.
map.merge(2, " Smoothie", (oldVal, newVal) -> oldVal + newVal);
map.merge(5, "Elderberry", (oldVal, newVal) -> oldVal + newVal);
System.out.println(map); 
// {1=APPLE, 2=Banana Smoothie, 3=Cherry Pie, 4=Date, 5=Elderberry}

üìò Full Java Program (Advanced Methods)
import java.util.*;
public class AdvancedMapMethodsExample {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();

        // putIfAbsent
        map.putIfAbsent(1, "Apple");
        map.putIfAbsent(2, "Banana");

        // getOrDefault
        System.out.println("Key 1: " + map.getOrDefault(1, "Default"));
        System.out.println("Key 3: " + map.getOrDefault(3, "Default"));

        // compute
        map.compute(1, (key, val) -> val.toUpperCase());
        map.compute(3, (key, val) -> "Cherry");

        // computeIfAbsent
        map.computeIfAbsent(4, key -> "Date");

        // computeIfPresent
        map.computeIfPresent(3, (key, val) -> val + " Pie");

        // merge
        map.merge(2, " Smoothie", (oldVal, newVal) -> oldVal + newVal);
        map.merge(5, "Elderberry", (oldVal, newVal) -> oldVal + newVal);

        // forEach
        System.out.println("\nFinal Map:");
        map.forEach((key, value) -> System.out.println(key + " -> " + value));
    }
}

üßæ Output
Key 1: Apple
Key 3: Default

Final Map:
1 -> APPLE
2 -> Banana Smoothie
3 -> Cherry Pie
4 -> Date
5 -> Elderberry
